<!doctype html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <style>
	  body { margin: 0; background-color: #000; font-family: Arial, sans-serif; }
    #3d-graph {
      transition: opacity 0.5s ease-in-out;
    }
	  #back-button {
		  position: fixed;
		  top: 20px;
		  left: 20px;
		  z-index: 1000;
		  background: rgba(255, 255, 255, 0.9);
		  border: 2px solid white;
		  color: black;
		  padding: 15px 25px;
		  border-radius: 8px;
		  cursor: pointer;
		  font-size: 16px;
		  font-weight: bold;
		  display: none;
		  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
	  }
	  #back-button:hover {
		  background: white;
	  }
    #reset-button {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 1000;
	    background: #111;
      border: none;
      box-shadow: none;
      outline: none;
      color: white;
      padding: 10px;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
    }
    #reset-button:hover {
      background: #444;
    }
    /* Hide the control instructions text */
    .scene-nav-info {
      display: none !important;
    }
  </style>
  
  <script src="//cdn.jsdelivr.net/npm/3d-force-graph"></script>
  <!--<script src="../../dist/3d-force-graph.js"></script>-->
</head>

<body>
<div id="3d-graph"></div>
<button id="back-button">返回上層</button>
<button id="reset-button">Reset</button>

<script type="module">
  import * as THREE from 'https://esm.sh/three';
  import SpriteText from "https://esm.sh/three-spritetext";
  import { forceZ, forceCollide, forceRadial } from 'https://esm.sh/d3-force-3d';

  let originalData = null;
  let currentLayer = 'main';
  let currentParent = null;
  let Graph = null;
  let focusedNode = null; // Track currently focused node
  let isTransitioning = false; // Track if we're in a transition

  fetch('./c-lab-data.json').then(res => res.json()).then(data => {
    originalData = data;

    // Preload all images (including child images)
    const allImageUrls = [];
    data.nodes.forEach(node => {
      if (node.type === 'image' && node.img) {
        allImageUrls.push(node.img);
      }
      if (node.children) {
        node.children.forEach(child => {
          if (child.type === 'image' && child.img) {
            allImageUrls.push(child.img);
          }
        });
      }
    });

    const textures = {};
    const loadingManager = new THREE.LoadingManager();
    const textureLoader = new THREE.TextureLoader(loadingManager);

    allImageUrls.forEach(url => {
      textureLoader.load(url, texture => {
        textures[url] = texture;
      });
    });

    loadingManager.onLoad = () => {
      initGraph(data, textures);
    };
  });

  function initGraph(data, textures) {
    Graph = ForceGraph3D()
    (document.getElementById('3d-graph'))
    .backgroundColor('#000000')
    .linkWidth(0.5)
    .linkDirectionalParticles(2)
    .nodeThreeObject(node => createNodeObject(node, textures))
    .onNodeClick(node => handleNodeClick(node, textures))
    .enableNodeDrag(true); // Explicitly enable node dragging

    loadMainLayer(data, textures);
    setupBackButton();
    setupResetButton();
  }

  function createTextureWithLabel(imgTexture, labelText) {
    // Create a canvas to combine image and text
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // Get original image dimensions
    const originalWidth = imgTexture.image.width;
    const originalHeight = imgTexture.image.height;
    
    // Fixed label dimensions (consistent across all images)
    const fixedLabelHeight = 50; // Increased height for even larger text
    const fixedFontSize = 26; // Increased font size
    const borderWidth = 3;
    const blackBorderWidth = 9;
    
    // Calculate canvas size based on image aspect ratio but with fixed label height
    const aspectRatio = originalWidth / originalHeight;
    let canvasWidth, canvasHeight;
    
    if (aspectRatio > 1) {
      // Landscape
      canvasWidth = 400; // Higher resolution
      canvasHeight = Math.round(400 / aspectRatio) + fixedLabelHeight + borderWidth * 2 + blackBorderWidth * 2;
    } else {
      // Portrait or square
      canvasHeight = 350 + fixedLabelHeight + borderWidth * 2 + blackBorderWidth * 2;
      canvasWidth = Math.round(350 * aspectRatio);
    }
    
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    
    // Improve text rendering quality
    ctx.textRenderingOptimization = 'optimizeQuality';
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    
    // Draw the original image
    const img = new Image();
    img.crossOrigin = 'anonymous';
    
    return new Promise((resolve) => {
      img.onload = () => {
        // Calculate image area dimensions
        const imageAreaHeight = canvasHeight - fixedLabelHeight;
        const imageAreaWidth = canvasWidth;
        
        // Fill background with white (thin outer border)
        ctx.fillStyle = 'white';
        ctx.fillRect(0, fixedLabelHeight, imageAreaWidth, imageAreaHeight);
        
        // Fill inner area with black (thick inner border)
        ctx.fillStyle = 'black';
        ctx.fillRect(borderWidth, fixedLabelHeight + borderWidth, 
                    imageAreaWidth - borderWidth * 2, imageAreaHeight - borderWidth * 2);
        
        // Draw image with border space
        const imageX = borderWidth + blackBorderWidth;
        const imageY = fixedLabelHeight + borderWidth + blackBorderWidth;
        const imageW = imageAreaWidth - (borderWidth + blackBorderWidth) * 2;
        const imageH = imageAreaHeight - (borderWidth + blackBorderWidth) * 2;
        
        ctx.drawImage(img, imageX, imageY, imageW, imageH);
        
        // Add text label ABOVE the white frame (FIXED SIZE)
        if (labelText) {
          // Fixed font size and measurements with better text rendering
          ctx.font = `bold ${fixedFontSize}px Arial, sans-serif`;
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          const textMetrics = ctx.measureText(labelText);
          const textWidth = textMetrics.width;
          
          // Fixed padding and dimensions
          const padding = 10;
          const labelWidth = textWidth + padding * 2;
          const labelHeight = fixedLabelHeight;
          
          // Position the label at top-left
          const labelX = 0;
          const labelY = 0;
          
          // Save context
          ctx.save();
          
          // Create path for label
          ctx.beginPath();
          ctx.rect(labelX, labelY, labelWidth, labelHeight);
          ctx.closePath();
          
          // Fill the label background (bright white)
          ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
          ctx.fill();
          
          // Add black border to the label
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // Text (fixed size, centered vertically with better rendering)
          ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
          ctx.font = `bold ${fixedFontSize}px Arial, sans-serif`;
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.fillText(labelText, labelX + padding, labelY + labelHeight / 2);
          
          ctx.restore();
        }
        
        // Create texture from canvas
        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;
        texture.generateMipmaps = false; // Better for text rendering
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        resolve(texture);
      };
      
      // Convert THREE texture to image
      img.src = imgTexture.image.src;
    });
  }

  function createNodeObject(node, textures) {
    if (node.type === 'image') {
      const imgTexture = textures[node.img];
      if (!imgTexture) {
        return new THREE.Object3D();
      }
      
      // For nodes with children (first layer), create texture with label
      if (node.children && node.children.length > 0 && node.name) {
        // Use a placeholder for now, we'll update this asynchronously
        const material = new THREE.SpriteMaterial({ 
          map: imgTexture,
          transparent: true, 
          opacity: isTransitioning ? 0 : 1
        });
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(60, 45);
        
        // Asynchronously create texture with label
        createTextureWithLabel(imgTexture, node.name).then(labeledTexture => {
          material.map = labeledTexture;
          material.needsUpdate = true;
        });
        
        return sprite;
      } 
      // For second layer nodes (children), also create texture with label if they have name
      else if (node.name) {
        // Use a placeholder for now, we'll update this asynchronously
        const material = new THREE.SpriteMaterial({ 
          map: imgTexture,
          transparent: true, 
          opacity: isTransitioning ? 0 : 1
        });
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(40, 30);
        
        // Asynchronously create texture with label for second layer
        createTextureWithLabel(imgTexture, node.name).then(labeledTexture => {
          material.map = labeledTexture;
          material.needsUpdate = true;
        });
        
        return sprite;
      }
      else {
        // Simple image without label
        imgTexture.colorSpace = THREE.SRGBColorSpace;
        const material = new THREE.SpriteMaterial({ 
          map: imgTexture, 
          transparent: true, 
          opacity: isTransitioning ? 0 : 1
        });
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(40, 30);
        return sprite;
      }
    } else if (node.type === 'text_box') {
      const sprite = new SpriteText(node.name, 6, 'white');
      sprite.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      sprite.padding = [16, 8];
      sprite.borderWidth = 2;
      sprite.borderColor = 'white';
      sprite.material.transparent = true;
      sprite.material.opacity = 1;
      return sprite;
    }
  }

  function loadMainLayer(data, textures) {
    currentLayer = 'main';
    currentParent = null;
    document.getElementById('back-button').style.display = 'none';

    // Fix center node to position 0,0,0
    const centerNode = data.nodes.find(n => n.id === 'center');
    if (centerNode) {
      centerNode.fx = 0;
      centerNode.fy = 0;
      centerNode.fz = 0;
    }

    Graph.graphData(data);

    // Apply original layer configurations
    // 第一層恢復較長的冷卻 tick，保有原本的力導引收斂效果
    Graph.warmupTicks(0);
    Graph.cooldownTicks(300);
    Graph.d3Force('charge').strength(-300);
    Graph.d3Force('link').distance(150);
    Graph.d3Force('z', forceZ(0).strength(0.1));
    Graph.d3Force('collide', forceCollide(55));
    Graph.d3Force('radial', forceRadial(300, 0, 0, 0).strength(0.02));

    // 回到第一層時重置相機位置，確保視角一致
    resetCamera(350, 800);
  }

  function loadSubLayer(parentNode, textures) {
    if (!parentNode.children || parentNode.children.length === 0) return;

    currentLayer = 'sub';
    currentParent = parentNode;
    document.getElementById('back-button').style.display = 'block';

    // Create sub-layer data with network connections (like main layer)
    const children = parentNode.children;
    const subLinks = [];

    // Create all-to-all connections like in main layer
    for (let i = 0; i < children.length; i++) {
      for (let j = i + 1; j < children.length; j++) {
        subLinks.push({
          source: children[i].id,
          target: children[j].id
        });
      }
    }

    const subData = {
      nodes: [...children],
      links: subLinks
    };

    Graph.graphData(subData);

    // Apply sub-layer configurations similar to main layer
    Graph.d3Force('charge').strength(-200);
    Graph.d3Force('link').distance(120);
    Graph.d3Force('z', forceZ(0).strength(0.1));
    Graph.d3Force('collide', forceCollide(45));
    Graph.d3Force('radial', forceRadial(200, 0, 0, 0).strength(0.03));

    // 進入第二層時重置相機位置，確保視角一致
    resetCamera(300, 800);
  }

  function fadeInNodes() {
    const { nodes } = Graph.graphData();
    const duration = 800;
    const startTime = Date.now();

    function animate() {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const opacity = progress;

      nodes.forEach(node => {
        if (node.__threeObj && node.__threeObj.material) {
          node.__threeObj.material.opacity = opacity;
        }
      });

      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        isTransitioning = false; // Transition complete
      }
    }

    requestAnimationFrame(animate);
  }

  // 將目前圖上的節點做淡出動畫
  function fadeOutNodes(onComplete, duration = 350) {
    const { nodes } = Graph.graphData();
    const startTime = Date.now();
    const startOpacities = new Map();

    nodes.forEach(node => {
      const mat = node.__threeObj && node.__threeObj.material;
      const start = mat ? (typeof mat.opacity === 'number' ? mat.opacity : 1) : 1;
      startOpacities.set(node, start);
    });

    function animate() {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const opacity = 1 - progress;

      nodes.forEach(node => {
        const mat = node.__threeObj && node.__threeObj.material;
        if (mat) {
          const start = startOpacities.get(node) ?? 1;
          mat.opacity = Math.max(0, start * opacity);
        }
      });

      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        if (typeof onComplete === 'function') onComplete();
      }
    }

    requestAnimationFrame(animate);
  }

  function transitionToLayer(loadFunction) {
    isTransitioning = true; // Mark that we're transitioning
    
    // Load new data immediately
    loadFunction();
    
    // Then fade in the new nodes
    setTimeout(() => {
      fadeInNodes();
    }, 50); // Smaller delay to reduce any flash
  }

  function animateScale(nodeObject, toScale) {
    const startScale = { x: nodeObject.scale.x, y: nodeObject.scale.y, z: nodeObject.scale.z };
    const duration = 600;
    const startTime = Date.now();

    function animate() {
      const elapsed = Date.now() - startTime;
      const t = Math.min(elapsed / duration, 1);
      const easeOut = 1 - Math.pow(1 - t, 2);

      nodeObject.scale.set(
        startScale.x + (toScale.x - startScale.x) * easeOut,
        startScale.y + (toScale.y - startScale.y) * easeOut,
        startScale.z + (toScale.z - startScale.z) * easeOut
      );

      if (t < 1) requestAnimationFrame(animate);
    }
    animate();
  }

  // 共用：重置相機到指定 z 距離並看向指定點
  function resetCamera(z = 300, duration = 800, lookAt = { x: 0, y: 0, z: 0 }) {
    Graph.cameraPosition(
      { x: 0, y: 0, z },
      lookAt,
      duration
    );
  }

  function handleNodeClick(node, textures) {
    if (currentLayer === 'main' && node.type === 'image' && node.children) {
      // 防止重複點擊
      if (isTransitioning) return;
      isTransitioning = true;
      
      // 先移動鏡頭聚焦到被點擊的卡片
      const nodePosition = node;
      const cameraDistance = 200; // 聚焦時的鏡頭距離
      
      // 計算鏡頭位置（稍微偏移以獲得更好的視角）
      const cameraPosition = {
        x: nodePosition.x + 50,
        y: nodePosition.y + 30,
        z: nodePosition.z + cameraDistance
      };
      
      // 鏡頭移動到節點位置
      Graph.cameraPosition(
        cameraPosition,
        { x: nodePosition.x, y: nodePosition.y, z: nodePosition.z }, // 看向節點
        1400 // 放慢鏡頭移動時間，讓 zoom in 更平滑
      );
      
      // 等待鏡頭移動完成後，先淡出第一層，再切換並淡入第二層
      setTimeout(() => {
        fadeOutNodes(() => {
          transitionToLayer(() => loadSubLayer(node, textures));
        }, 350);
      }, 1500); // 與鏡頭移動時間對齊
      
    } else if (currentLayer === 'sub' && node.type === 'image') {
      const baseScale = { x: 40, y: 30, z: 1 };
      const targetScale = { x: baseScale.x * 1.3, y: baseScale.y * 1.3, z: baseScale.z };

      // Shrink previous focused node
      if (focusedNode && focusedNode !== node && focusedNode.__threeObj) {
        animateScale(focusedNode.__threeObj, baseScale);
      }

      // Enlarge current node, only if it's not already focused
      if (node !== focusedNode && node.__threeObj) {
        animateScale(node.__threeObj, targetScale);
      }
      
      focusedNode = node; // Update focused node
    }
  }

  function setupBackButton() {
    document.getElementById('back-button').addEventListener('click', () => {
      if (currentLayer === 'sub') {
        transitionToLayer(() => loadMainLayer(originalData));
      }
    });
  }

  function setupResetButton() {
    document.getElementById('reset-button').addEventListener('click', () => {
      if (currentLayer === 'sub') {
        // Reset sub layer - stay in sub layer but reset its state
        transitionToLayer(() => loadSubLayer(currentParent));
        
        // Reset camera to a closer position for sub layer
        setTimeout(() => {
          Graph.cameraPosition(
            { x: 0, y: 0, z: 300 }, // Closer camera position for sub layer
            { x: 0, y: 0, z: 0 },   // Look at center
            1000 // Transition duration
          );
        }, 100);
      } else {
        // Reset main layer
        loadMainLayer(originalData);
        
        // Reset camera position to closer default view for main layer
        setTimeout(() => {
          Graph.cameraPosition(
            { x: 0, y: 0, z: 350 }, // Closer camera position for main layer
            { x: 0, y: 0, z: 0 },   // Look at center
            1000 // Transition duration
          );
        }, 100);
      }
      
      // Reset focused node
      focusedNode = null;
    });
  }
</script>
</body>
</html>